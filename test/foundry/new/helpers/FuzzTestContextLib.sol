// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import { Vm } from "forge-std/Vm.sol";

import { LibPRNG } from "solady/src/utils/LibPRNG.sol";

import "seaport-sol/SeaportSol.sol";

import { Account } from "../BaseOrderTest.sol";

import { Result } from "./FuzzHelpers.sol";

import { ExpectedBalances } from "./ExpectedBalances.sol";

import { CriteriaResolverHelper } from "./CriteriaResolverHelper.sol";

import {
    AmountDeriverHelper
} from "../../../../contracts/helpers/sol/lib/fulfillment/AmountDeriverHelper.sol";

import {
    OrderStatus as OrderStatusEnum
} from "../../../../contracts/helpers/sol/SpaceEnums.sol";

struct FuzzParams {
    uint256 seed;
    uint256 totalOrders;
    uint256 maxOfferItems;
    uint256 maxConsiderationItems;
}

struct ReturnValues {
    bool fulfilled;
    bool cancelled;
    bool validated;
    bool[] availableOrders;
    Execution[] executions;
}

interface TestHelpers {
    function balanceChecker() external view returns (ExpectedBalances);

    function amountDeriverHelper() external view returns (AmountDeriverHelper);

    function criteriaResolverHelper()
        external
        view
        returns (CriteriaResolverHelper);

    function makeAccount(
        string memory name
    ) external view returns (Account memory);

    function getMatchedFulfillments(
        AdvancedOrder[] memory orders,
        CriteriaResolver[] memory resolvers
    )
        external
        returns (
            Fulfillment[] memory fulfillments,
            MatchComponent[] memory remainingOfferComponents,
            MatchComponent[] memory remainingConsiderationComponents
        );

    function getMatchedFulfillments(
        OrderDetails[] memory orders
    )
        external
        returns (
            Fulfillment[] memory fulfillments,
            MatchComponent[] memory remainingOfferComponents,
            MatchComponent[] memory remainingConsiderationComponents
        );

    function toOrderDetails(
        AdvancedOrder[] memory orders,
        CriteriaResolver[] memory resolvers
    ) external returns (OrderDetails[] memory);
}

struct FuzzTestContext {
    bytes4 _action;
    /**
     * @dev A Seaport interface, either the reference or optimized version.
     */
    SeaportInterface seaport;
    /**
     * @dev A ConduitController interface.
     */
    ConduitControllerInterface conduitController;
    /**
     * @dev A caller address. If this is nonzero, the FuzzEngine will prank this
     *      address before calling exec.
     */
    address caller;
    /**
     * @dev A recipient address to be passed into fulfillAdvancedOrder,
     *      fulfillAvailableAdvancedOrders, or matchAdvancedOrders. Speciying a
     *      recipient on the fulfill functions will set that address as the
     *      recipient for all received items.  Specifying a recipient on the
     *      match function will set that address as the recipient for all
     *      unspent offer item amounts.
     */
    address recipient;
    /**
     * @dev A struct containing fuzzed params generated by the Foundry fuzzer.
     *      Right now these params include only a uint256 seed, which we could
     *      potentially use to generate other random data.
     */
    FuzzParams fuzzParams;
    /**
     * @dev An array of AdvancedOrders
     */
    AdvancedOrder[] orders;
    /**
     * @dev A copy of the original orders array. Use this to make assertions
     *      about the final state of the orders after calling exec. This is
     *      automatically copied if you use the FuzzTestContextLib.from() function.
     */
    AdvancedOrder[] initialOrders;
    /**
     * @dev Additional data we might need to fulfill an order. This is basically
     *      the superset of all the non-order args to SeaportInterface
     *      functions, like conduit key, criteria resolvers, and fulfillments.
     *      Use FuzzTestContextLib.from() to create a FuzzTestContext with these
     *      fields pre-populated with empty defaults.
     */
    /**
     * @dev A counter that can be incremented to cancel all orders made with
     *      the same counter value.
     */
    uint256 counter;
    /**
     * @dev Indicates what conduit, if any, to check for token approvals. A zero
     *      value means no conduit, look to seaport itself.
     */
    bytes32 fulfillerConduitKey;
    /**
     * @dev An array of CriteriaResolvers. These allow specification of an
     *      order, offer or consideration, an identifier, and a proof.  They
     *      enable trait offer and collection offers, etc.
     */
    CriteriaResolver[] criteriaResolvers;
    /**
     * @dev An array of Fulfillments. These are used in the match functions to
     *      point offers and considerations to one another.
     */
    Fulfillment[] fulfillments;
    /**
     * @dev offer components not explicitly supplied in match fulfillments.
     */
    FulfillmentComponent[] remainingOfferComponents;
    /**
     * @dev An array of FulfillmentComponents. These are used in the
     *      fulfillAvailable functions to set up aggregations.
     */
    FulfillmentComponent[][] offerFulfillments;
    FulfillmentComponent[][] considerationFulfillments;
    /**
     * @dev The maximum number of fulfillments to attempt in the
     *      fulfillAvailable functions.
     */
    uint256 maximumFulfilled;
    /**
     * @dev A struct containing basic order parameters that are used in the
     *      fulfillBasic functions.
     */
    BasicOrderParameters basicOrderParameters;
    OrderStatusEnum[] preExecOrderStatuses;
    /**
     * @dev A struct containing test helpers. These are used to generate
     *      accounts and fulfillments.
     */
    TestHelpers testHelpers;
    /**
     * @dev An array of function selectors for "checks". The FuzzEngine will
     *      call these functions after calling exec to make assertions about
     *      the resulting test state.
     */
    bytes4[] checks;
    /**
     * @dev Expected zone calldata hashes.
     */
    bytes32[] expectedZoneCalldataHash;
    /**
     * @dev Expected contract order calldata hashes. Index 0 of the outer array
     *      corresponds to the generateOrder hash, while index 1 corresponds to
     *      the ratifyOrder hash.
     */
    bytes32[2][] expectedContractOrderCalldataHashes;
    /**
     * @dev Expected Result state for each order. Indexes correspond to the
     *      indexes of the orders in the orders array.
     */
    Result[] expectedResults;
    /**
     * @dev Expected executions.  Implicit means it doesn't correspond directly
     *      with a fulfillment that was passed in.
     */
    Execution[] expectedImplicitExecutions;
    Execution[] expectedExplicitExecutions;
    Execution[] allExpectedExecutions;
    /**
     * @dev Expected event hashes. Encompasses all events that match watched topic0s.
     */
    bytes32[] expectedEventHashes;
    /**
     * @dev Actual events emitted.
     */
    Vm.Log[] actualEvents;
    /**
     * @dev Return values from the last call to exec. Superset of return values
     *      from all Seaport functions.
     */
    ReturnValues returnValues;
}

/**
 * @notice Builder library for FuzzTestContext.
 */
library FuzzTestContextLib {
    using AdvancedOrderLib for AdvancedOrder;
    using AdvancedOrderLib for AdvancedOrder[];
    using BasicOrderParametersLib for BasicOrderParameters;
    using FuzzTestContextLib for FuzzTestContext;
    using LibPRNG for LibPRNG.PRNG;

    /**
     * @dev Create an empty FuzzTestContext.
     *
     * @custom:return emptyContext the empty FuzzTestContext
     */
    function empty() internal view returns (FuzzTestContext memory) {
        AdvancedOrder[] memory orders;
        CriteriaResolver[] memory resolvers;
        Fulfillment[] memory fulfillments;
        FulfillmentComponent[] memory components;
        FulfillmentComponent[][] memory componentsArray;
        bytes4[] memory checks;
        Result[] memory results;
        bool[] memory available;
        Execution[] memory executions;
        bytes32[] memory hashes;
        bytes32[] memory expectedEventHashes;
        Vm.Log[] memory actualEvents;

        return
            FuzzTestContext({
                _action: bytes4(0),
                orders: orders,
                seaport: SeaportInterface(address(0)),
                conduitController: ConduitControllerInterface(address(0)),
                caller: address(0),
                fuzzParams: FuzzParams({
                    seed: 0,
                    totalOrders: 0,
                    maxOfferItems: 0,
                    maxConsiderationItems: 0
                }),
                checks: checks,
                counter: 0,
                fulfillerConduitKey: bytes32(0),
                criteriaResolvers: resolvers,
                recipient: address(0),
                fulfillments: fulfillments,
                remainingOfferComponents: components,
                offerFulfillments: componentsArray,
                considerationFulfillments: componentsArray,
                maximumFulfilled: 0,
                preExecOrderStatuses: new OrderStatusEnum[](0),
                basicOrderParameters: BasicOrderParametersLib.empty(),
                initialOrders: orders,
                expectedResults: results,
                returnValues: ReturnValues({
                    fulfilled: false,
                    cancelled: false,
                    validated: false,
                    availableOrders: available,
                    executions: executions
                }),
                expectedZoneCalldataHash: hashes,
                expectedContractOrderCalldataHashes: new bytes32[2][](0),
                expectedImplicitExecutions: executions,
                expectedExplicitExecutions: executions,
                allExpectedExecutions: executions,
                expectedEventHashes: expectedEventHashes,
                actualEvents: actualEvents,
                testHelpers: TestHelpers(address(this))
            });
    }

    /**
     * @dev Create a FuzzTestContext from the given partial arguments.
     *
     * @param orders the AdvancedOrder[] to set
     * @param seaport the SeaportInterface to set
     * @param caller the caller address to set
     * @custom:return _context the FuzzTestContext
     */
    function from(
        AdvancedOrder[] memory orders,
        SeaportInterface seaport,
        address caller
    ) internal view returns (FuzzTestContext memory) {
        return
            empty()
                .withOrders(orders)
                .withSeaport(seaport)
                .withCaller(caller)
                .withInitialOrders(orders.copy());
    }

    /**
     * @dev Sets the orders on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the orders of
     * @param orders the AdvancedOrder[] to set
     *
     * @return _context the FuzzTestContext with the orders set
     */
    function withOrders(
        FuzzTestContext memory context,
        AdvancedOrder[] memory orders
    ) internal pure returns (FuzzTestContext memory) {
        context.orders = orders.copy();
        return context;
    }

    function withInitialOrders(
        FuzzTestContext memory context,
        AdvancedOrder[] memory orders
    ) internal pure returns (FuzzTestContext memory) {
        context.initialOrders = orders.copy();
        return context;
    }

    /**
     * @dev Sets the SeaportInterface on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the SeaportInterface of
     * @param seaport the SeaportInterface to set
     *
     * @return _context the FuzzTestContext with the SeaportInterface set
     */
    function withSeaport(
        FuzzTestContext memory context,
        SeaportInterface seaport
    ) internal pure returns (FuzzTestContext memory) {
        context.seaport = seaport;
        return context;
    }

    /**
     * @dev Sets the ConduitControllerInterface on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the ConduitControllerInterface of
     * @param conduitController the ConduitControllerInterface to set
     *
     * @return _context the FuzzTestContext with the ConduitControllerInterface set
     */
    function withConduitController(
        FuzzTestContext memory context,
        ConduitControllerInterface conduitController
    ) internal pure returns (FuzzTestContext memory) {
        context.conduitController = conduitController;
        return context;
    }

    /**
     * @dev Sets the caller on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the caller of
     * @param caller the caller address to set
     *
     * @return _context the FuzzTestContext with the caller set
     */
    function withCaller(
        FuzzTestContext memory context,
        address caller
    ) internal pure returns (FuzzTestContext memory) {
        context.caller = caller;
        return context;
    }

    /**
     * @dev Sets the fuzzParams on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the fuzzParams of
     * @param fuzzParams the fuzzParams struct to set
     *
     * @return _context the FuzzTestContext with the fuzzParams set
     */
    function withFuzzParams(
        FuzzTestContext memory context,
        FuzzParams memory fuzzParams
    ) internal pure returns (FuzzTestContext memory) {
        context.fuzzParams = _copyFuzzParams(fuzzParams);
        return context;
    }

    /**
     * @dev Sets the checks on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the checks of
     * @param checks the checks array to set
     *
     * @return _context the FuzzTestContext with the checks set
     */
    function withChecks(
        FuzzTestContext memory context,
        bytes4[] memory checks
    ) internal pure returns (FuzzTestContext memory) {
        context.checks = _copyBytes4(checks);
        return context;
    }

    /**
     * @dev Sets the counter on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the counter of
     * @param counter the counter value to set
     *
     * @return _context the FuzzTestContext with the counter set
     */
    function withCounter(
        FuzzTestContext memory context,
        uint256 counter
    ) internal pure returns (FuzzTestContext memory) {
        context.counter = counter;
        return context;
    }

    /**
     * @dev Sets the fulfillerConduitKey on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the fulfillerConduitKey of
     * @param fulfillerConduitKey the fulfillerConduitKey value to set
     *
     * @return _context the FuzzTestContext with the fulfillerConduitKey set
     */
    function withFulfillerConduitKey(
        FuzzTestContext memory context,
        bytes32 fulfillerConduitKey
    ) internal pure returns (FuzzTestContext memory) {
        context.fulfillerConduitKey = fulfillerConduitKey;
        return context;
    }

    /**
     * @dev Sets the criteriaResolvers on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the criteriaResolvers of
     * @param criteriaResolvers the criteriaResolvers array to set
     *
     * @return _context the FuzzTestContext with the criteriaResolvers set
     */
    function withCriteriaResolvers(
        FuzzTestContext memory context,
        CriteriaResolver[] memory criteriaResolvers
    ) internal pure returns (FuzzTestContext memory) {
        context.criteriaResolvers = _copyCriteriaResolvers(criteriaResolvers);
        return context;
    }

    /**
     * @dev Sets the recipient on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the recipient of
     * @param recipient the recipient value to set
     *
     * @return _context the FuzzTestContext with the recipient set
     */
    function withRecipient(
        FuzzTestContext memory context,
        address recipient
    ) internal pure returns (FuzzTestContext memory) {
        context.recipient = recipient;
        return context;
    }

    /**
     * @dev Sets the fulfillments on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the fulfillments of
     * @param fulfillments the offerFulfillments value to set
     *
     * @return _context the FuzzTestContext with the fulfillments set
     */
    function withFulfillments(
        FuzzTestContext memory context,
        Fulfillment[] memory fulfillments
    ) internal pure returns (FuzzTestContext memory) {
        context.fulfillments = fulfillments;
        return context;
    }

    /**
     * @dev Sets the offerFulfillments on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the offerFulfillments of
     * @param offerFulfillments the offerFulfillments value to set
     *
     * @return _context the FuzzTestContext with the offerFulfillments set
     */
    function withOfferFulfillments(
        FuzzTestContext memory context,
        FulfillmentComponent[][] memory offerFulfillments
    ) internal pure returns (FuzzTestContext memory) {
        context.offerFulfillments = _copyFulfillmentComponents(
            offerFulfillments
        );
        return context;
    }

    /**
     * @dev Sets the considerationFulfillments on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the considerationFulfillments of
     * @param considerationFulfillments the considerationFulfillments value to set
     *
     * @return _context the FuzzTestContext with the considerationFulfillments set
     */
    function withConsiderationFulfillments(
        FuzzTestContext memory context,
        FulfillmentComponent[][] memory considerationFulfillments
    ) internal pure returns (FuzzTestContext memory) {
        context.considerationFulfillments = _copyFulfillmentComponents(
            considerationFulfillments
        );
        return context;
    }

    /**
     * @dev Sets the maximumFulfilled on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the maximumFulfilled of
     * @param maximumFulfilled the maximumFulfilled value to set
     *
     * @return _context the FuzzTestContext with maximumFulfilled set
     */
    function withMaximumFulfilled(
        FuzzTestContext memory context,
        uint256 maximumFulfilled
    ) internal pure returns (FuzzTestContext memory) {
        context.maximumFulfilled = maximumFulfilled;
        return context;
    }

    /**
     * @dev Sets the basicOrderParameters on a FuzzTestContext
     *
     * @param context the FuzzTestContext to set the fulfillments of
     * @param basicOrderParameters the offerFulfillments value to set
     *
     * @return _context the FuzzTestContext with the fulfillments set
     */
    function withBasicOrderParameters(
        FuzzTestContext memory context,
        BasicOrderParameters memory basicOrderParameters
    ) internal pure returns (FuzzTestContext memory) {
        context.basicOrderParameters = basicOrderParameters;
        return context;
    }

    /**
     * @dev Sets a pseudorandom OrderStatus for each order on a FuzzTestContext.
     *      The preExecOrderStatuses are indexed to orders.
     *
     *
     * @param context the FuzzTestContext to set the preExecOrderStatuses of
     *
     * @return _context the FuzzTestContext with the preExecOrderStatuses set
     */
    function withPreExecOrderStatuses(
        FuzzTestContext memory context
    ) internal pure returns (FuzzTestContext memory) {
        LibPRNG.PRNG memory prng = LibPRNG.PRNG(context.fuzzParams.seed);

        context.preExecOrderStatuses = new OrderStatusEnum[](
            context.orders.length
        );

        for (uint256 i = 0; i < context.orders.length; i++) {
            context.preExecOrderStatuses[i] = OrderStatusEnum(
                uint8(bound(prng.next(), 0, 6))
            );
        }

        return context;
    }

    function _copyBytes4(
        bytes4[] memory selectors
    ) private pure returns (bytes4[] memory) {
        bytes4[] memory copy = new bytes4[](selectors.length);
        for (uint256 i = 0; i < selectors.length; i++) {
            copy[i] = selectors[i];
        }
        return copy;
    }

    function _copyFulfillmentComponents(
        FulfillmentComponent[][] memory fulfillmentComponents
    ) private pure returns (FulfillmentComponent[][] memory) {
        FulfillmentComponent[][]
            memory outerCopy = new FulfillmentComponent[][](
                fulfillmentComponents.length
            );
        for (uint256 i = 0; i < fulfillmentComponents.length; i++) {
            FulfillmentComponent[]
                memory innerCopy = new FulfillmentComponent[](
                    fulfillmentComponents[i].length
                );
            for (uint256 j = 0; j < fulfillmentComponents[i].length; j++) {
                innerCopy[j] = fulfillmentComponents[i][j];
            }
            outerCopy[i] = innerCopy;
        }
        return outerCopy;
    }

    function _copyCriteriaResolvers(
        CriteriaResolver[] memory criteriaResolvers
    ) private pure returns (CriteriaResolver[] memory) {
        CriteriaResolver[] memory copy = new CriteriaResolver[](
            criteriaResolvers.length
        );
        for (uint256 i = 0; i < criteriaResolvers.length; i++) {
            copy[i] = criteriaResolvers[i];
        }
        return copy;
    }

    function _copyFuzzParams(
        FuzzParams memory params
    ) private pure returns (FuzzParams memory) {
        return
            FuzzParams({
                seed: params.seed,
                totalOrders: params.totalOrders,
                maxOfferItems: params.maxOfferItems,
                maxConsiderationItems: params.maxConsiderationItems
            });
    }
}

// @dev Implementation cribbed from forge-std bound
function bound(
    uint256 x,
    uint256 min,
    uint256 max
) pure returns (uint256 result) {
    require(min <= max, "Max is less than min.");
    // If x is between min and max, return x directly. This is to ensure that
    // dictionary values do not get shifted if the min is nonzero.
    if (x >= min && x <= max) return x;

    uint256 size = max - min + 1;

    // If the value is 0, 1, 2, 3, warp that to min, min+1, min+2, min+3.
    // Similarly for the UINT256_MAX side. This helps ensure coverage of the
    // min/max values.
    if (x <= 3 && size > x) return min + x;
    if (x >= type(uint256).max - 3 && size > type(uint256).max - x)
        return max - (type(uint256).max - x);

    // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
    if (x > max) {
        uint256 diff = x - max;
        uint256 rem = diff % size;
        if (rem == 0) return max;
        result = min + rem - 1;
    } else if (x < min) {
        uint256 diff = min - x;
        uint256 rem = diff % size;
        if (rem == 0) return min;
        result = max - rem + 1;
    }
}
